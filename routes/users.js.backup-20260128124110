const express = require('express');
const bcrypt = require('bcryptjs');
const FirestoreDAO = require('../utils/firestore-dao');
const fs = require('fs');
const path = require('path');

const router = express.Router();

// Initialize Firestore DAOs
const usersDAO = new FirestoreDAO('users');
const profilesDAO = new FirestoreDAO('profiles');
const hostelDAO = new FirestoreDAO('hostel');
const requestsDAO = new FirestoreDAO('requests');
const { createNotification } = require('../config/firebase-config');

// Temporary JSON helper functions (TODO: Migrate these endpoints to use Firestore DAOs)
const DATA_DIR = path.join(__dirname, '../data');
const USERS_FILE = path.join(DATA_DIR, 'users.json');
const PROFILES_FILE = path.join(DATA_DIR, 'profiles.json');
const HOSTEL_FILE = path.join(DATA_DIR, 'hostel.json');
const REQUESTS_FILE = path.join(DATA_DIR, 'requests.json');
const NOTIFICATIONS_FILE = path.join(DATA_DIR, 'notifications.json');

const loadUsers = () => {
    try {
        if (fs.existsSync(USERS_FILE)) {
            const data = fs.readFileSync(USERS_FILE, 'utf8');
            return JSON.parse(data);
        }
    } catch (error) {
        console.error('Error loading users:', error);
    }
    return {};
};

const saveUsers = (users) => {
    try {
        fs.writeFileSync(USERS_FILE, JSON.stringify(users, null, 2));
        return true;
    } catch (error) {
        console.error('Error saving users:', error);
        return false;
    }
};

const loadProfiles = () => {
    try {
        if (fs.existsSync(PROFILES_FILE)) {
            const data = fs.readFileSync(PROFILES_FILE, 'utf8');
            return JSON.parse(data);
        }
    } catch (error) {
        console.error('Error loading profiles:', error);
    }
    return {};
};

const saveProfiles = (profiles) => {
    try {
        fs.writeFileSync(PROFILES_FILE, JSON.stringify(profiles, null, 2));
        return true;
    } catch (error) {
        console.error('Error saving profiles:', error);
        return false;
    }
};

const loadHostelData = () => {
    try {
        if (fs.existsSync(HOSTEL_FILE)) {
            const data = fs.readFileSync(HOSTEL_FILE, 'utf8');
            return JSON.parse(data);
        }
    } catch (error) {
        console.error('Error loading hostel data:', error);
    }
    return {};
};

const saveHostelData = (hostelData) => {
    try {
        fs.writeFileSync(HOSTEL_FILE, JSON.stringify(hostelData, null, 2));
        return true;
    } catch (error) {
        console.error('Error saving hostel data:', error);
        return false;
    }
};

const loadRequests = () => {
    try {
        if (fs.existsSync(REQUESTS_FILE)) {
            const data = fs.readFileSync(REQUESTS_FILE, 'utf8');
            return JSON.parse(data);
        }
    } catch (error) {
        console.error('Error loading requests:', error);
    }
    return [];
};

const saveRequests = (requests) => {
    try {
        fs.writeFileSync(REQUESTS_FILE, JSON.stringify(requests, null, 2));
        return true;
    } catch (error) {
        console.error('Error saving requests:', error);
        return false;
    }
};

const loadNotifications = () => {
    try {
        if (fs.existsSync(NOTIFICATIONS_FILE)) {
            const data = fs.readFileSync(NOTIFICATIONS_FILE, 'utf8');
            return JSON.parse(data);
        }
    } catch (error) {
        console.error('Error loading notifications:', error);
    }
    return [];
};

const saveNotifications = (notifications) => {
    try {
        fs.writeFileSync(NOTIFICATIONS_FILE, JSON.stringify(notifications, null, 2));
        return true;
    } catch (error) {
        console.error('Error saving notifications:', error);
        return false;
    }
};

// Helper functions for cascade delete operations
const deleteUserCascade = async (userEmail) => {
    try {
        // Delete user profile
        const profile = await profilesDAO.findById(userEmail);
        if (profile) {
            await profilesDAO.delete(userEmail);
        }
        
        // Delete hostel data
        const hostel = await hostelDAO.findById(userEmail);
        if (hostel) {
            await hostelDAO.delete(userEmail);
        }
        
        // Delete requests
        const requests = await requestsDAO.findByField('studentInfo.studentEmail', userEmail);
        for (const request of requests) {
            await requestsDAO.delete(request.id);
        }
        
        return true;
    } catch (error) {
        console.error('Error in cascade delete:', error);
        return false;
    }
};

// Comprehensive cascade delete function
const cascadeDeleteUser = (email) => {
    const deletionResults = {
        user: false,
        profile: false,
        hostel: false,
        requests: 0,
        notifications: 0,
        attendanceEnrollments: 0,
        attendanceRecords: 0,
        attendanceSummaries: 0,
        errors: []
    };
    
    try {
        // 1. Delete from users database
        const users = loadUsers();
        if (users[email]) {
            delete users[email];
            deletionResults.user = saveUsers(users);
            if (!deletionResults.user) {
                deletionResults.errors.push('Failed to save users after deletion');
            }
        }
        
        // 2. Delete from profiles database
        const profiles = loadProfiles();
        console.log(`üîç Checking profiles for email: ${email}`);
        console.log(`üìã Profile keys in database:`, Object.keys(profiles));
        
        // Check for both full email and username-only formats
        const emailKey = email;
        const usernameKey = email.split('@')[0];
        let profileDeleted = false;
        
        if (profiles[emailKey]) {
            console.log(`‚úÖ Found profile with full email key: ${emailKey}`);
            delete profiles[emailKey];
            profileDeleted = true;
        }
        
        if (profiles[usernameKey]) {
            console.log(`‚úÖ Found profile with username key: ${usernameKey}`);
            delete profiles[usernameKey];
            profileDeleted = true;
        }
        
        if (profileDeleted) {
            deletionResults.profile = saveProfiles(profiles);
            if (!deletionResults.profile) {
                deletionResults.errors.push('Failed to save profiles after deletion');
            } else {
                console.log(`‚úÖ Profile deleted and saved successfully for: ${email}`);
            }
        } else {
            console.log(`‚ÑπÔ∏è No profile found for: ${email} (neither ${emailKey} nor ${usernameKey})`);
        }
        
        // 3. Delete from hostel database
        const hostelData = loadHostelData();
        console.log(`üè† Checking hostel data for email: ${email}`);
        console.log(`üìã Hostel keys in database:`, Object.keys(hostelData));
        
        let hostelDeleted = false;
        
        if (hostelData[emailKey]) {
            console.log(`‚úÖ Found hostel data with full email key: ${emailKey}`);
            delete hostelData[emailKey];
            hostelDeleted = true;
        }
        
        if (hostelData[usernameKey]) {
            console.log(`‚úÖ Found hostel data with username key: ${usernameKey}`);
            delete hostelData[usernameKey];
            hostelDeleted = true;
        }
        
        if (hostelDeleted) {
            deletionResults.hostel = saveHostelData(hostelData);
            if (!deletionResults.hostel) {
                deletionResults.errors.push('Failed to save hostel data after deletion');
            } else {
                console.log(`‚úÖ Hostel data deleted and saved successfully for: ${email}`);
            }
        } else {
            console.log(`‚ÑπÔ∏è No hostel data found for: ${email}`);
        }
        
        // 4. Delete user's requests
        const requests = loadRequests();
        const initialRequestCount = requests.length;
        const filteredRequests = requests.filter(req => req.studentEmail !== email);
        deletionResults.requests = initialRequestCount - filteredRequests.length;
        if (deletionResults.requests > 0) {
            const requestsSaved = saveRequests(filteredRequests);
            if (!requestsSaved) {
                deletionResults.errors.push('Failed to save requests after deletion');
            }
        }
        
        // 5. Delete user's notifications
        const notifications = loadNotifications();
        const initialNotificationCount = notifications.length;
        const filteredNotifications = notifications.filter(notif => notif.studentEmail !== email);
        deletionResults.notifications = initialNotificationCount - filteredNotifications.length;
        if (deletionResults.notifications > 0) {
            const notificationsSaved = saveNotifications(filteredNotifications);
            if (!notificationsSaved) {
                deletionResults.errors.push('Failed to save notifications after deletion');
            }
        }
        
        // 6. Delete attendance system data (enrollments, records, summaries)
        try {
            const ENROLLMENTS_FILE = path.join(DATA_DIR, 'attendance-enrollments.json');
            const RECORDS_FILE = path.join(DATA_DIR, 'attendance-records.json');
            const SUMMARIES_FILE = path.join(DATA_DIR, 'attendance-summaries.json');
            const AUDIT_FILE = path.join(DATA_DIR, 'attendance-audit-logs.json');
            
            console.log(`üìä Deleting attendance data for user: ${email}`);
            
            // Delete enrollments
            if (fs.existsSync(ENROLLMENTS_FILE)) {
                const enrollments = JSON.parse(fs.readFileSync(ENROLLMENTS_FILE, 'utf8'));
                const enrollmentKeys = Object.keys(enrollments);
                const enrollmentsToDelete = enrollmentKeys.filter(key => 
                    enrollments[key].studentEmail === email
                );
                
                enrollmentsToDelete.forEach(key => {
                    console.log(`  üóëÔ∏è Deleting enrollment: ${key}`);
                    delete enrollments[key];
                    deletionResults.attendanceEnrollments++;
                });
                
                if (deletionResults.attendanceEnrollments > 0) {
                    fs.writeFileSync(ENROLLMENTS_FILE, JSON.stringify(enrollments, null, 2));
                    console.log(`‚úÖ Deleted ${deletionResults.attendanceEnrollments} enrollment(s)`);
                }
            }
            
            // Delete attendance records
            if (fs.existsSync(RECORDS_FILE)) {
                const records = JSON.parse(fs.readFileSync(RECORDS_FILE, 'utf8'));
                const recordKeys = Object.keys(records);
                
                recordKeys.forEach(key => {
                    const record = records[key];
                    if (record.attendance && Array.isArray(record.attendance)) {
                        const initialLength = record.attendance.length;
                        record.attendance = record.attendance.filter(a => a.studentEmail !== email);
                        
                        if (record.attendance.length < initialLength) {
                            // Update counts
                            record.totalStudents = record.attendance.length;
                            record.presentCount = record.attendance.filter(a => a.status === 'present').length;
                            record.absentCount = record.attendance.filter(a => a.status === 'absent').length;
                            deletionResults.attendanceRecords++;
                        }
                    }
                });
                
                if (deletionResults.attendanceRecords > 0) {
                    fs.writeFileSync(RECORDS_FILE, JSON.stringify(records, null, 2));
                    console.log(`‚úÖ Removed student from ${deletionResults.attendanceRecords} attendance record(s)`);
                }
            }
            
            // Delete attendance summaries
            if (fs.existsSync(SUMMARIES_FILE)) {
                const summaries = JSON.parse(fs.readFileSync(SUMMARIES_FILE, 'utf8'));
                const summaryKeys = Object.keys(summaries);
                const summariesToDelete = summaryKeys.filter(key => 
                    summaries[key].studentEmail === email
                );
                
                summariesToDelete.forEach(key => {
                    console.log(`  üóëÔ∏è Deleting attendance summary: ${key}`);
                    delete summaries[key];
                    deletionResults.attendanceSummaries++;
                });
                
                if (deletionResults.attendanceSummaries > 0) {
                    fs.writeFileSync(SUMMARIES_FILE, JSON.stringify(summaries, null, 2));
                    console.log(`‚úÖ Deleted ${deletionResults.attendanceSummaries} attendance summary/summaries`);
                }
            }
            
            // Add audit log for user deletion
            if (fs.existsSync(AUDIT_FILE)) {
                const auditLogs = JSON.parse(fs.readFileSync(AUDIT_FILE, 'utf8'));
                auditLogs.push({
                    id: Date.now().toString(),
                    action: 'DELETE_USER_CASCADE',
                    details: {
                        deletedUserEmail: email,
                        enrollmentsDeleted: deletionResults.attendanceEnrollments,
                        recordsModified: deletionResults.attendanceRecords,
                        summariesDeleted: deletionResults.attendanceSummaries
                    },
                    userEmail: 'system',
                    timestamp: new Date().toISOString()
                });
                
                if (auditLogs.length > 1000) {
                    auditLogs.splice(0, auditLogs.length - 1000);
                }
                
                fs.writeFileSync(AUDIT_FILE, JSON.stringify(auditLogs, null, 2));
            }
            
            console.log(`‚úÖ Attendance data cleanup completed`);
            
        } catch (attendanceError) {
            console.error('‚ùå Error deleting attendance data:', attendanceError);
            deletionResults.errors.push(`Attendance data deletion error: ${attendanceError.message}`);
        }
        
        // 7. Delete profile pictures and uploaded documents (if any)
        try {
            const uploadsDir = path.join(__dirname, '../uploads');
            const profilePicturesDir = path.join(uploadsDir, 'profile-pictures');
            const profilesDir = path.join(uploadsDir, 'profiles');
            const supportingDocsDir = path.join(uploadsDir, 'supporting-documents');
            
            let deletedFilesCount = 0;
            
            // Delete profile pictures from 'profile-pictures' directory
            if (fs.existsSync(profilePicturesDir)) {
                const files = fs.readdirSync(profilePicturesDir);
                const userFiles = files.filter(file => file.includes(usernameKey));
                userFiles.forEach(file => {
                    try {
                        fs.unlinkSync(path.join(profilePicturesDir, file));
                        console.log(`üóëÔ∏è Deleted profile picture: ${file}`);
                        deletedFilesCount++;
                    } catch (err) {
                        console.warn(`‚ö†Ô∏è Failed to delete profile picture ${file}:`, err.message);
                    }
                });
            }
            
            // Delete profile pictures from 'profiles' directory
            if (fs.existsSync(profilesDir)) {
                const files = fs.readdirSync(profilesDir);
                const userFiles = files.filter(file => file.includes(usernameKey));
                userFiles.forEach(file => {
                    try {
                        fs.unlinkSync(path.join(profilesDir, file));
                        console.log(`üóëÔ∏è Deleted profile picture: ${file}`);
                        deletedFilesCount++;
                    } catch (err) {
                        console.warn(`‚ö†Ô∏è Failed to delete profile picture ${file}:`, err.message);
                    }
                });
            }
            
            // Delete supporting documents
            if (fs.existsSync(supportingDocsDir)) {
                const files = fs.readdirSync(supportingDocsDir);
                const userFiles = files.filter(file => file.includes(usernameKey));
                userFiles.forEach(file => {
                    try {
                        fs.unlinkSync(path.join(supportingDocsDir, file));
                        console.log(`üóëÔ∏è Deleted supporting document: ${file}`);
                        deletedFilesCount++;
                    } catch (err) {
                        console.warn(`‚ö†Ô∏è Failed to delete supporting document ${file}:`, err.message);
                    }
                });
            }
            
            if (deletedFilesCount > 0) {
                console.log(`‚úÖ Deleted ${deletedFilesCount} file(s) for user: ${email}`);
            } else {
                console.log(`‚ÑπÔ∏è No files found to delete for user: ${email}`);
            }
        } catch (fileError) {
            console.warn('Warning: Error cleaning up user files:', fileError.message);
            deletionResults.errors.push(`File cleanup warning: ${fileError.message}`);
        }
        
    } catch (error) {
        deletionResults.errors.push(`Cascade delete error: ${error.message}`);
    }
    
    return deletionResults;
};

// Validate email domain
const isValidEmail = (email) => {
    return email && email.endsWith('@gmcpnalanda.com');
};

// Generate unique ID
const generateId = () => {
    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);
};

// Generate role-based ID
const generateRoleId = (role, existingUsers) => {
    const prefix = {
        'admin': 'ADM',
        'management': 'MNG',
        'teacher': 'TCH',
        'student': 'STU'
    }[role] || 'USR';

    const existing = Object.values(existingUsers)
        .filter(u => u.role === role && u.employeeId?.startsWith(prefix))
        .map(u => parseInt(u.employeeId.replace(prefix, '')))
        .filter(n => !isNaN(n));

    const nextNumber = existing.length > 0 ? Math.max(...existing) + 1 : 1;
    return `${prefix}${nextNumber.toString().padStart(3, '0')}`;
};

// Middleware to validate session (reuse from auth.js)
const validateSession = (req, res, next) => {
    console.log(`üîí Session validation for ${req.method} ${req.path}`);
    console.log(`üîí Request headers:`, req.headers);
    console.log(`üîí Request cookies:`, req.cookies);
    
    // For now, we'll temporarily disable session validation to fix the immediate issue
    // In production, this should validate the actual session token properly
    console.log('‚úÖ Session validation temporarily bypassed for development');
    next();
};

// Initialize default users endpoint (for debugging)
router.post('/init-defaults', (req, res) => {
    try {
        console.log('üîÑ Initializing default users...');
        const users = loadUsers(); // This will create defaults if file is empty
        
        res.json({
            success: true,
            message: 'Default users initialized',
            userCount: Object.keys(users).length
        });
    } catch (error) {
        console.error('Error initializing default users:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to initialize default users'
        });
    }
});

// Get all users (admin only)
router.get('/', validateSession, (req, res) => {
    try {
        const users = loadUsers();
        
        // Remove passwords from response
        const safeUsers = Object.values(users).map(user => {
            const { password, ...safeUser } = user;
            return safeUser;
        });
        
        res.json({
            success: true,
            users: safeUsers
        });
    } catch (error) {
        console.error('Get users error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to fetch users'
        });
    }
});

// Get all users (JSON-based)
router.get('/', validateSession, (req, res) => {
    try {
        const users = loadUsers();
        
        // Convert object to array and remove passwords
        const userArray = Object.values(users).map(user => {
            const { password, ...safeUser } = user;
            return safeUser;
        });
        
        res.json({
            success: true,
            users: userArray
        });
    } catch (error) {
        console.error('Get users list error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to fetch users'
        });
    }
});

// Get user by email
router.get('/:email', validateSession, (req, res) => {
    try {
        const users = loadUsers();
        const user = users[req.params.email];
        
        if (!user) {
            return res.status(404).json({
                success: false,
                error: 'User not found'
            });
        }
        
        // Remove password from response
        const { password, ...safeUser } = user;
        
        res.json({
            success: true,
            user: safeUser
        });
    } catch (error) {
        console.error('Get user error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to fetch user'
        });
    }
});

// Create new user
router.post('/', validateSession, async (req, res) => {
    try {
        const userData = req.body;
        console.log('üîç DEBUG: Received userData:', JSON.stringify(userData, null, 2));
        
        // Validate required fields
        if (!userData.name || !userData.email || !userData.password || !userData.role) {
            return res.status(400).json({
                success: false,
                error: 'Name, email, password, and role are required'
            });
        }
        
        // Validate email domain
        if (!isValidEmail(userData.email)) {
            return res.status(400).json({
                success: false,
                error: 'Email must be from @gmcpnalanda.com domain'
            });
        }
        
        const users = loadUsers();
        
        // Check if user already exists
        if (users[userData.email]) {
            return res.status(400).json({
                success: false,
                error: 'User with this email already exists'
            });
        }
        
        // Validate password
        if (userData.password.length < 8) {
            return res.status(400).json({
                success: false,
                error: 'Password must be at least 8 characters long'
            });
        }
        
        // Hash password before storing
        const hashedPassword = await bcrypt.hash(userData.password, 10);
        
        // Create user object with only basic info
        const newUser = {
            id: generateId(),
            email: userData.email,
            password: hashedPassword,
            role: userData.role,
            name: userData.name,
            status: 'active',
            createdAt: new Date().toISOString(),
            lastLogin: null,
            mustChangePassword: userData.requirePasswordChange !== false // Default to true unless explicitly set to false
        };
        
        // ONLY add role-specific fields if they are explicitly provided in request
        // Students will fill their own profile, teachers/management/admin can be added later if needed
        console.log('üîç DEBUG: newUser before role-specific fields:', JSON.stringify(newUser, null, 2));
        if (userData.role === 'student') {
            // Only add studentId if explicitly provided
            if (userData.studentId) newUser.studentId = userData.studentId;
            if (userData.rollNumber) newUser.rollNumber = userData.rollNumber;
            if (userData.course) newUser.course = userData.course;
            if (userData.year) newUser.year = parseInt(userData.year);
            if (userData.semester) newUser.semester = parseInt(userData.semester);
            if (userData.section) newUser.section = userData.section;
            if (userData.branch) newUser.branch = userData.branch;
        }
        console.log('üîç DEBUG: newUser AFTER student fields:', JSON.stringify(newUser, null, 2));
        
        if (userData.role === 'teacher') {
            // Only add if explicitly provided
            if (userData.employeeId) newUser.employeeId = userData.employeeId;
            if (userData.department) newUser.department = userData.department;
            if (userData.subjects) newUser.subjects = userData.subjects;
            if (userData.classes) newUser.classes = userData.classes;
            if (userData.qualification) newUser.qualification = userData.qualification;
            if (userData.experience) newUser.experience = userData.experience;
        } else if (userData.role === 'management') {
            // Only add if explicitly provided
            if (userData.employeeId) newUser.employeeId = userData.employeeId;
            if (userData.department) newUser.department = userData.department;
            if (userData.designation) newUser.designation = userData.designation;
            if (userData.permissions) newUser.permissions = userData.permissions;
        } else if (userData.role === 'admin') {
            // Only add if explicitly provided
            if (userData.employeeId) newUser.employeeId = userData.employeeId;
            if (userData.department) newUser.department = userData.department;
            if (userData.permissions) newUser.permissions = userData.permissions;
        }
        
        // Save user to local file system
        users[userData.email] = newUser;
        
        if (saveUsers(users)) {
            console.log(`‚úÖ User saved to local database: ${newUser.name} (${newUser.role})`);
            
            // Also try to create user in Firebase (if enabled, optional, non-blocking)
            if (process.env.DISABLE_FIREBASE !== 'true') {
                try {
                    await createFirebaseUser(
                        userData.email, 
                        userData.password, 
                        userData.name,
                        { role: userData.role }
                    );
                    console.log(`üî• User also created in Firebase: ${userData.email}`);
                } catch (firebaseError) {
                    console.warn(`‚ö†Ô∏è  Firebase user creation failed (continuing with local storage): ${firebaseError.message}`);
                }
            } else {
                console.log(`üó∫ Firebase disabled - user created in local storage only: ${userData.email}`);
            }
            
            // Remove password from response
            const { password, ...safeUser } = newUser;
            
            console.log(`‚úÖ User created successfully: ${newUser.name} (${newUser.role})`);
            
            res.status(201).json({
                success: true,
                message: 'User created successfully',
                user: safeUser
            });
        } else {
            console.error(`‚ùå Failed to save user to local database: ${userData.email}`);
            res.status(500).json({
                success: false,
                error: 'Failed to save user'
            });
        }
        
    } catch (error) {
        console.error('Create user error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to create user'
        });
    }
});

// Update user
router.put('/:email', validateSession, (req, res) => {
    try {
        const email = req.params.email;
        const updates = req.body;
        const users = loadUsers();
        
        if (!users[email]) {
            return res.status(404).json({
                success: false,
                error: 'User not found'
            });
        }
        
        // Prevent email changes
        delete updates.email;
        delete updates.id;
        delete updates.createdAt;
        
        // Update user data
        users[email] = { ...users[email], ...updates };
        
        if (saveUsers(users)) {
            // Remove password from response
            const { password, ...safeUser } = users[email];
            
            res.json({
                success: true,
                message: 'User updated successfully',
                user: safeUser
            });
        } else {
            res.status(500).json({
                success: false,
                error: 'Failed to update user'
            });
        }
    } catch (error) {
        console.error('Update user error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to update user'
        });
    }
});

// Delete user with cascade delete (removes ALL user data)
router.delete('/:email', validateSession, async (req, res) => {
    try {
        const email = req.params.email;
        console.log(`üóëÔ∏è CASCADE DELETE request for user: ${email}`);
        
        const users = loadUsers();
        console.log(`üìã Current users in database: ${Object.keys(users).join(', ')}`);
        
        if (!users[email]) {
            console.log(`‚ùå User not found: ${email}`);
            return res.status(404).json({
                success: false,
                error: 'User not found'
            });
        }
        
        // Store user info before deletion for the response
        const userInfo = {
            email: email,
            name: users[email].name,
            role: users[email].role
        };
        
        console.log(`üîÑ Starting cascade delete for user: ${email} (${userInfo.name})`);
        
        // STEP 1: Delete from Firestore collections (profiles, hostel, requests)
        console.log('üî• Step 1: Deleting from Firestore collections...');
        try {
            await deleteUserCascade(email);
            console.log('‚úÖ Firestore data deleted successfully');
            deletionResults.firestoreDeleted = true;
        } catch (firestoreError) {
            console.error('‚ùå Firestore deletion error:', firestoreError);
            deletionResults.errors.push(`Firestore deletion failed: ${firestoreError.message}`);
            deletionResults.firestoreDeleted = false;
        }
        
        // STEP 2: Delete from JSON files (local storage)
        console.log('üíæ Step 2: Deleting from JSON files...');
        const deletionResults = cascadeDeleteUser(email);
        
        // STEP 3: Delete from Firebase Authentication
        if (process.env.DISABLE_FIREBASE !== 'true') {
            console.log('üîê Step 3: Deleting from Firebase Authentication...');
            try {
                await deleteFirebaseUser(email);
                console.log(`‚úÖ Firebase Auth user deleted: ${email}`);
                deletionResults.firebaseAuthDeleted = true;
            } catch (firebaseError) {
                console.warn(`‚ö†Ô∏è Firebase Auth deletion failed: ${firebaseError.message}`);
                deletionResults.errors.push(`Firebase Auth deletion failed: ${firebaseError.message}`);
                deletionResults.firebaseAuthDeleted = false;
            }
        } else {
            console.log(`üó∫ Firebase disabled - performing local cascade delete only`);
        }
        
        // Log deletion results
        console.log(`‚úÖ Cascade delete completed for ${email}:`);
        console.log(`   - Firestore collections: ${deletionResults.firestoreDeleted ? '‚úÖ Deleted' : '‚ùå Failed'}`);
        console.log(`   - Firebase Authentication: ${deletionResults.firebaseAuthDeleted ? '‚úÖ Deleted' : '‚û°Ô∏è Skipped/Failed'}`);
        console.log(`   - User account (JSON): ${deletionResults.user ? '‚úÖ Deleted' : '‚ùå Failed'}`);
        console.log(`   - Profile data (JSON): ${deletionResults.profile ? '‚úÖ Deleted' : '‚û°Ô∏è Not found'}`);
        console.log(`   - Hostel data (JSON): ${deletionResults.hostel ? '‚úÖ Deleted' : '‚û°Ô∏è Not found'}`);
        console.log(`   - Requests deleted: ${deletionResults.requests}`);
        console.log(`   - Notifications deleted: ${deletionResults.notifications}`);
        console.log(`   - Attendance enrollments deleted: ${deletionResults.attendanceEnrollments}`);
        console.log(`   - Attendance records modified: ${deletionResults.attendanceRecords}`);
        console.log(`   - Attendance summaries deleted: ${deletionResults.attendanceSummaries}`);
        
        if (deletionResults.errors.length > 0) {
            console.warn(`‚ö†Ô∏è Deletion warnings/errors:`);
            deletionResults.errors.forEach(error => console.warn(`   - ${error}`));
        }
        
        // Check if the main user deletion succeeded
        if (deletionResults.user || deletionResults.errors.length === 0) {
            res.json({
                success: true,
                message: `User and all associated data deleted successfully from entire system`,
                deletedUser: userInfo,
                deletionSummary: {
                    firestoreCollections: deletionResults.firestoreDeleted,
                    firebaseAuthentication: deletionResults.firebaseAuthDeleted || false,
                    userAccount: deletionResults.user,
                    profileData: deletionResults.profile,
                    hostelData: deletionResults.hostel,
                    requestsDeleted: deletionResults.requests,
                    notificationsDeleted: deletionResults.notifications,
                    attendanceEnrollmentsDeleted: deletionResults.attendanceEnrollments,
                    attendanceRecordsModified: deletionResults.attendanceRecords,
                    attendanceSummariesDeleted: deletionResults.attendanceSummaries,
                    warnings: deletionResults.errors.length > 0 ? deletionResults.errors : undefined
                }
            });
        } else {
            console.error(`‚ùå Critical failure in cascade delete for ${email}`);
            res.status(500).json({
                success: false,
                error: 'Failed to delete user and associated data',
                details: deletionResults.errors
            });
        }
        
    } catch (error) {
        console.error('Delete user error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to delete user: ' + error.message
        });
    }
});

// Admin reset user password
router.post('/reset-password', validateSession, async (req, res) => {
    try {
        const { email, newPassword, requirePasswordChange } = req.body;
        
        // Validate required fields
        if (!email || !newPassword) {
            return res.status(400).json({
                success: false,
                error: 'Email and new password are required'
            });
        }
        
        // Validate email domain
        if (!isValidEmail(email)) {
            return res.status(400).json({
                success: false,
                error: 'Email must be from @gmcpnalanda.com domain'
            });
        }
        
        // Validate password
        if (newPassword.length < 8) {
            return res.status(400).json({
                success: false,
                error: 'Password must be at least 8 characters long'
            });
        }
        
        const users = loadUsers();
        
        if (!users[email]) {
            return res.status(404).json({
                success: false,
                error: 'User not found'
            });
        }
        
        // Hash password before storing
        const hashedPassword = await bcrypt.hash(newPassword, 10);
        
        // Update user password and require password change flag
        users[email].password = hashedPassword;
        users[email].mustChangePassword = requirePasswordChange !== false; // Default true
        users[email].passwordResetAt = new Date().toISOString();
        
        if (saveUsers(users)) {
            console.log(`‚úÖ Password reset for user: ${email}`);
            res.json({
                success: true,
                message: 'Password reset successfully'
            });
        } else {
            res.status(500).json({
                success: false,
                error: 'Failed to update password'
            });
        }
        
    } catch (error) {
        console.error('Reset password error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to reset password'
        });
    }
});

// User change own password
router.post('/change-password', async (req, res) => {
    try {
        const { email, currentPassword, newPassword } = req.body;
        
        // Validate required fields
        if (!email || !currentPassword || !newPassword) {
            return res.status(400).json({
                success: false,
                error: 'Email, current password, and new password are required'
            });
        }
        
        // Validate email domain
        if (!isValidEmail(email)) {
            return res.status(400).json({
                success: false,
                error: 'Email must be from @gmcpnalanda.com domain'
            });
        }
        
        // Validate new password
        if (newPassword.length < 8) {
            return res.status(400).json({
                success: false,
                error: 'New password must be at least 8 characters long'
            });
        }
        
        const users = loadUsers();
        const user = users[email];
        
        if (!user) {
            return res.status(404).json({
                success: false,
                error: 'User not found'
            });
        }
        
        // Verify current password using bcrypt
        const isPasswordValid = await bcrypt.compare(currentPassword, user.password);
        if (!isPasswordValid) {
            return res.status(401).json({
                success: false,
                error: 'Current password is incorrect'
            });
        }
        
        // Hash new password
        const hashedPassword = await bcrypt.hash(newPassword, 10);
        
        // Update password
        users[email].password = hashedPassword;
        users[email].mustChangePassword = false; // Reset flag after user changes password
        users[email].passwordChangedAt = new Date().toISOString();
        
        if (saveUsers(users)) {
            console.log(`‚úÖ Password changed for user: ${email}`);
            res.json({
                success: true,
                message: 'Password changed successfully'
            });
        } else {
            res.status(500).json({
                success: false,
                error: 'Failed to update password'
            });
        }
        
    } catch (error) {
        console.error('Change password error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to change password'
        });
    }
});

// Authenticate user (for login)
router.post('/authenticate', async (req, res) => {
    try {
        const { email, password } = req.body;
        
        if (!email || !password) {
            return res.status(400).json({
                success: false,
                error: 'Email and password are required'
            });
        }
        
        if (!isValidEmail(email)) {
            return res.status(400).json({
                success: false,
                error: 'Only @gmcpnalanda.com email addresses are allowed'
            });
        }
        
        const users = loadUsers();
        const user = users[email];
        
        if (!user) {
            return res.status(401).json({
                success: false,
                error: 'No account found with this email address'
            });
        }
        
        // Hybrid authentication: Firebase + Local password verification
        if (process.env.DISABLE_FIREBASE !== 'true') {
            try {
                // Check if user exists in Firebase first
                const firebaseUserExists = await verifyFirebaseUser(email, password);
                
                if (firebaseUserExists) {
                    // User exists in Firebase, now verify password using bcrypt
                    const isPasswordValid = await bcrypt.compare(password, user.password);
                    if (!isPasswordValid) {
                        console.log(`üîí Password verification failed for Firebase user: ${email}`);
                        return res.status(401).json({
                            success: false,
                            error: 'Incorrect password'
                        });
                    }
                    console.log(`üîì Firebase + Local password verification successful: ${email}`);
                } else {
                    // User doesn't exist in Firebase, fallback to local-only
                    console.log(`üó∫ User not in Firebase, using local verification: ${email}`);
                    const isPasswordValid = await bcrypt.compare(password, user.password);
                    if (!isPasswordValid) {
                        return res.status(401).json({
                            success: false,
                            error: 'Incorrect password'
                        });
                    }
                    console.log(`‚úÖ Local password verification successful: ${email}`);
                }
            } catch (firebaseError) {
                console.warn(`‚ö†Ô∏è  Firebase verification failed, falling back to local password: ${firebaseError.message}`);
                // Fallback to local password check using bcrypt
                const isPasswordValid = await bcrypt.compare(password, user.password);
                if (!isPasswordValid) {
                    return res.status(401).json({
                        success: false,
                        error: 'Incorrect password'
                    });
                }
                console.log(`‚úÖ Local password verification successful (Firebase fallback): ${email}`);
            }
        } else {
            // Firebase disabled - use bcrypt for local password verification
            console.log(`üó∫ Local password verification for: ${email}`);
            const isPasswordValid = await bcrypt.compare(password, user.password);
            if (!isPasswordValid) {
                return res.status(401).json({
                    success: false,
                    error: 'Incorrect password'
                });
            }
            console.log(`‚úÖ Local password verification successful for: ${email}`);
        }
        
        if (user.status !== 'active') {
            return res.status(401).json({
                success: false,
                error: 'Your account is inactive. Please contact administrator'
            });
        }
        
        // Update last login
        users[email].lastLogin = new Date().toISOString();
        saveUsers(users);
        
        // Remove password from response but include mustChangePassword flag
        const { password: _, ...safeUser } = user;
        
        res.json({
            success: true,
            message: 'Authentication successful',
            user: safeUser,
            requirePasswordReset: user.mustChangePassword || false
        });
        
    } catch (error) {
        console.error('Authentication error:', error);
        res.status(500).json({
            success: false,
            error: 'Authentication failed'
        });
    }
});

// ===== BULK OPERATIONS ENDPOINTS =====

// Bulk create users
router.post('/bulk-create', validateSession, async (req, res) => {
    try {
        const { users: usersToCreate } = req.body;
        
        if (!usersToCreate || !Array.isArray(usersToCreate) || usersToCreate.length === 0) {
            return res.status(400).json({
                success: false,
                error: 'Users array is required and must not be empty'
            });
        }
        
        const users = loadUsers();
        const results = {
            created: 0,
            skipped: 0,
            errors: 0,
            details: []
        };
        
        console.log(`\ud83d\udce5 Bulk creating ${usersToCreate.length} users...`);
        
        for (const userData of usersToCreate) {
            try {
                // Validate required fields
                if (!userData.name || !userData.email || !userData.role) {
                    results.errors++;
                    results.details.push({
                        email: userData.email || 'Unknown',
                        status: 'error',
                        message: 'Missing required fields (name, email, role)'
                    });
                    continue;
                }
                
                // Validate email domain
                if (!isValidEmail(userData.email)) {
                    results.errors++;
                    results.details.push({
                        email: userData.email,
                        status: 'error',
                        message: 'Invalid email domain (must be @gmcpnalanda.com)'
                    });
                    continue;
                }
                
                // Check if user already exists
                if (users[userData.email]) {
                    results.skipped++;
                    results.details.push({
                        email: userData.email,
                        status: 'skipped',
                        message: 'User already exists'
                    });
                    continue;
                }
                
                // Set default password if not provided
                const password = userData.password || 'TempPass123!';
                
                // Hash password
                const hashedPassword = await bcrypt.hash(password, 10);
                
                // Create user object
                const newUser = {
                    id: generateId(),
                    email: userData.email,
                    password: hashedPassword,
                    role: userData.role,
                    name: userData.name,
                    status: 'active',
                    createdAt: new Date().toISOString(),
                    lastLogin: null,
                    mustChangePassword: userData.mustChangePassword !== false // Default true
                };
                
                // ONLY add role-specific fields if they are explicitly provided in request
                // Students will fill their own profile, teachers/management/admin can be added later if needed
                if (userData.role === 'student') {
                    // Only add if explicitly provided
                    if (userData.studentId) newUser.studentId = userData.studentId;
                    if (userData.rollNumber) newUser.rollNumber = userData.rollNumber;
                    if (userData.course) newUser.course = userData.course;
                    if (userData.year) newUser.year = userData.year;
                    if (userData.semester) newUser.semester = userData.semester;
                    if (userData.section) newUser.section = userData.section;
                } else if (userData.role === 'teacher') {
                    // Only add if explicitly provided
                    if (userData.employeeId) newUser.employeeId = userData.employeeId;
                    if (userData.department) newUser.department = userData.department;
                    if (userData.subjects) newUser.subjects = userData.subjects;
                    if (userData.classes) newUser.classes = userData.classes;
                } else if (userData.role === 'management') {
                    // Only add if explicitly provided
                    if (userData.employeeId) newUser.employeeId = userData.employeeId;
                    if (userData.designation) newUser.designation = userData.designation;
                    if (userData.department) newUser.department = userData.department;
                } else if (userData.role === 'admin') {
                    // Only add if explicitly provided
                    if (userData.employeeId) newUser.employeeId = userData.employeeId;
                    if (userData.department) newUser.department = userData.department;
                    if (userData.permissions) newUser.permissions = userData.permissions;
                }
                
                // Add user to the database
                users[userData.email] = newUser;
                
                results.created++;
                results.details.push({
                    email: userData.email,
                    status: 'created',
                    message: 'User created successfully',
                    id: newUser.id,
                    roleId: newUser.studentId || newUser.employeeId || null
                });
                
                console.log(`\u2705 Created user: ${userData.email} (${userData.role})`);
                
            } catch (userError) {
                console.error(`\u274c Error creating user ${userData.email}:`, userError);
                results.errors++;
                results.details.push({
                    email: userData.email,
                    status: 'error',
                    message: `Creation failed: ${userError.message}`
                });
            }
        }
        
        // Save all changes at once
        if (results.created > 0) {
            if (saveUsers(users)) {
                console.log(`\u2705 Bulk creation completed: ${results.created} created, ${results.skipped} skipped, ${results.errors} errors`);
                
                res.json({
                    success: true,
                    message: `Bulk creation completed`,
                    created: results.created,
                    skipped: results.skipped,
                    errors: results.errors,
                    details: results.details
                });
            } else {
                res.status(500).json({
                    success: false,
                    error: 'Failed to save users to database',
                    results: results
                });
            }
        } else {
            res.json({
                success: false,
                message: 'No users were created',
                created: 0,
                skipped: results.skipped,
                errors: results.errors,
                details: results.details
            });
        }
        
    } catch (error) {
        console.error('Bulk create users error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to create users: ' + error.message
        });
    }
});

// Bulk delete users
router.post('/bulk-delete', validateSession, async (req, res) => {
    try {
        const { emails } = req.body;
        
        if (!emails || !Array.isArray(emails) || emails.length === 0) {
            return res.status(400).json({
                success: false,
                error: 'Emails array is required and must not be empty'
            });
        }
        
        const users = loadUsers();
        const results = {
            deleted: 0,
            notFound: 0,
            errors: 0,
            details: []
        };
        
        console.log(`\ud83d\uddd1\ufe0f Bulk deleting ${emails.length} users...`);
        
        for (const email of emails) {
            try {
                if (!users[email]) {
                    results.notFound++;
                    results.details.push({
                        email: email,
                        status: 'not_found',
                        message: 'User not found'
                    });
                    continue;
                }
                
                // Store user info before deletion for the response
                const userInfo = {
                    email: email,
                    name: users[email].name,
                    role: users[email].role
                };
                
                // Perform cascade delete for this user
                const deletionResults = cascadeDeleteUser(email);
                
                // Optionally try to delete from Firebase (non-blocking)
                if (process.env.DISABLE_FIREBASE !== 'true') {
                    try {
                        await deleteFirebaseUser(email);
                        console.log(`\ud83d\udd25 Also deleted from Firebase: ${email}`);
                    } catch (firebaseError) {
                        console.warn(`\u26a0\ufe0f  Firebase deletion failed for ${email}: ${firebaseError.message}`);
                        deletionResults.errors.push(`Firebase deletion failed: ${firebaseError.message}`);
                    }
                }
                
                if (deletionResults.user) {
                    results.deleted++;
                    results.details.push({
                        ...userInfo,
                        status: 'deleted',
                        message: 'User and all associated data deleted successfully',
                        deletionSummary: {
                            profileData: deletionResults.profile,
                            hostelData: deletionResults.hostel,
                            requestsDeleted: deletionResults.requests,
                            notificationsDeleted: deletionResults.notifications,
                            warnings: deletionResults.errors.length > 0 ? deletionResults.errors : undefined
                        }
                    });
                    console.log(`\u2705 Cascade deleted user: ${email}`);
                } else {
                    throw new Error('User deletion failed during cascade delete');
                }
                
            } catch (userError) {
                console.error(`\u274c Error deleting user ${email}:`, userError);
                results.errors++;
                results.details.push({
                    email: email,
                    status: 'error',
                    message: `Deletion failed: ${userError.message}`
                });
            }
        }
        
        // Return results (no need to save - cascade delete handles individual saves)
        if (results.deleted > 0) {
            console.log(`\u2705 Bulk cascade deletion completed: ${results.deleted} deleted, ${results.notFound} not found, ${results.errors} errors`);
            
            res.json({
                success: true,
                message: `Bulk cascade deletion completed - all user data removed`,
                processedCount: results.deleted,
                deleted: results.deleted,
                notFound: results.notFound,
                errors: results.errors,
                details: results.details
            });
        } else {
            res.json({
                success: false,
                message: 'No users were deleted',
                processedCount: 0,
                deleted: 0,
                notFound: results.notFound,
                errors: results.errors,
                details: results.details
            });
        }
        
    } catch (error) {
        console.error('Bulk delete users error:', error);
        res.status(500).json({
            success: false,
            error: 'Failed to delete users: ' + error.message
        });
    }
});

// Bulk activate/deactivate users
router.post('/bulk-activate', validateSession, (req, res) => {
    bulkStatusChange(req, res, 'active');
});

router.post('/bulk-deactivate', validateSession, (req, res) => {
    bulkStatusChange(req, res, 'inactive');
});

// Helper function for bulk status changes
function bulkStatusChange(req, res, newStatus) {
    try {
        const { emails } = req.body;
        
        if (!emails || !Array.isArray(emails) || emails.length === 0) {
            return res.status(400).json({
                success: false,
                error: 'Emails array is required and must not be empty'
            });
        }
        
        const users = loadUsers();
        const results = {
            updated: 0,
            notFound: 0,
            errors: 0,
            details: []
        };
        
        console.log(`\ud83d\udd04 Bulk ${newStatus === 'active' ? 'activating' : 'deactivating'} ${emails.length} users...`);
        
        for (const email of emails) {
            try {
                if (!users[email]) {
                    results.notFound++;
                    results.details.push({
                        email: email,
                        status: 'not_found',
                        message: 'User not found'
                    });
                    continue;
                }
                
                // Update user status
                users[email].status = newStatus;
                users[email].statusUpdatedAt = new Date().toISOString();
                
                results.updated++;
                results.details.push({
                    email: email,
                    name: users[email].name,
                    role: users[email].role,
                    status: 'updated',
                    message: `User ${newStatus === 'active' ? 'activated' : 'deactivated'} successfully`,
                    newStatus: newStatus
                });
                
                console.log(`\u2705 ${newStatus === 'active' ? 'Activated' : 'Deactivated'} user: ${email}`);
                
            } catch (userError) {
                console.error(`\u274c Error updating user ${email}:`, userError);
                results.errors++;
                results.details.push({
                    email: email,
                    status: 'error',
                    message: `Status update failed: ${userError.message}`
                });
            }
        }
        
        // Save changes
        if (results.updated > 0) {
            if (saveUsers(users)) {
                console.log(`\u2705 Bulk status update completed: ${results.updated} updated, ${results.notFound} not found, ${results.errors} errors`);
                
                res.json({
                    success: true,
                    message: `Bulk ${newStatus === 'active' ? 'activation' : 'deactivation'} completed`,
                    processedCount: results.updated,
                    updated: results.updated,
                    notFound: results.notFound,
                    errors: results.errors,
                    details: results.details
                });
            } else {
                res.status(500).json({
                    success: false,
                    error: 'Failed to save status changes'
                });
            }
        } else {
            res.json({
                success: false,
                message: 'No users were updated',
                processedCount: 0,
                updated: 0,
                notFound: results.notFound,
                errors: results.errors,
                details: results.details
            });
        }
        
    } catch (error) {
        console.error(`Bulk ${newStatus} users error:`, error);
        res.status(500).json({
            success: false,
            error: `Failed to ${newStatus === 'active' ? 'activate' : 'deactivate'} users: ` + error.message
        });
    }
}

module.exports = router;
